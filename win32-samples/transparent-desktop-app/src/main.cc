#include <Windows.h>

#include <tchar.h>
#include <iostream>

static TCHAR s_WindowClassName[] = _T("DesktopApp");
static TCHAR s_Title[]           = _T("Transparent Desktop App");

LRESULT WINAPI WndProc(_In_ HWND hWnd, _In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam) {
  switch (uMsg) {
    case WM_DESTROY: {
      PostQuitMessage(0);
    } break;
    default:
      return DefWindowProc(hWnd, uMsg, wParam, lParam);
  }

  return 0;
}

int mGetLastErrorMessage(DWORD errorCode) {
  // reference: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage

  DWORD dwFlags      = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;
  LPCVOID lpSource   = NULL;
  DWORD dwMessageId  = errorCode;
  DWORD dwLanguageId = 0;
  LPTSTR lpBuffer    = NULL;
  DWORD nSize        = 0;
  va_list* Arguments = NULL;

  size_t errorMessageSize = FormatMessage(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);

  if (errorMessageSize == 0) {
    // We will not call FormatMessage for this error because it may become infinite loop if we are not using the API correct.
    DWORD lastErrorCode = GetLastError();
    std::cout << "FormatMessage failed at error code " << lastErrorCode << std::endl;
    return -1;
  }

  std::wcout << lpBuffer << std::endl;
  LocalFree(lpBuffer);

  return 0;
}

int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) {
  DWORD errorCode;
  WNDCLASSEX wcex;

  // If we don't initialize every fields in the WNDCLASSEX struct, there will be memory access violation errors.
  wcex.cbSize        = sizeof(WNDCLASSEX);
  wcex.style         = CS_HREDRAW | CS_VREDRAW;
  wcex.lpfnWndProc   = WndProc;
  wcex.cbClsExtra    = 0;
  wcex.cbWndExtra    = 0;
  wcex.hInstance     = hInstance;
  wcex.hIcon         = LoadIcon(hInstance, IDI_APPLICATION);
  wcex.hCursor       = LoadCursor(NULL, IDC_ARROW);
  wcex.hbrBackground = (HBRUSH)0;
  wcex.lpszMenuName  = NULL;
  wcex.lpszClassName = s_WindowClassName;
  wcex.hIconSm       = LoadIcon(wcex.hInstance, IDI_APPLICATION);

  ATOM rce_ret = RegisterClassEx(&wcex);
  if (rce_ret == 0) {
    // RegisterClassEx failed
    errorCode = GetLastError();
    std::cout << "RegisterClassEx failed with error code " << errorCode << std::endl;
    mGetLastErrorMessage(errorCode);
    return -1;
  }

  // TODO Do we have to store the HINSTANCE in global variable? The sample code generated by Visual Studio stores it.

  // TODO Do we have to change any flags to make the window transparent?
  HWND hWnd = CreateWindow(s_WindowClassName, s_Title, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 320, 320, NULL, NULL, hInstance, NULL);

  if (hWnd == NULL) {
    errorCode = GetLastError();
    std::cout << "CreateWindow failed with error code " << errorCode << std::endl;
    mGetLastErrorMessage(errorCode);
    return -1;
  }

  ShowWindow(hWnd, nCmdShow);
  UpdateWindow(hWnd);

  MSG msg;
  while (GetMessage(&msg, NULL, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }

  return (int)msg.wParam;
}

int main() {
  return wWinMain(GetModuleHandle(NULL), NULL, GetCommandLine(), SW_SHOWNORMAL);
}
